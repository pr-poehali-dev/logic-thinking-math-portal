import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import Icon from "@/components/ui/icon";
import PuzzleGrid from "./puzzle/PuzzleGrid";
import PuzzleDetail from "./puzzle/PuzzleDetail";
import { usePuzzleState } from "@/hooks/usePuzzleState";
import { puzzleCategories } from "@/data/puzzleData";
import { useState } from "react";
import GradeSixTasks from "@/components/GradeSixTasks";

const EntertainingProblemsSection = () => {
  const [selectedTopic, setSelectedTopic] = useState<string | null>(null);
  const [selectedSubtopic, setSelectedSubtopic] = useState<string | null>(null);
  const [showSolutions, setShowSolutions] = useState<{
    [key: string]: boolean;
  }>({});
  const [activeTab, setActiveTab] = useState("logic");

  // Puzzle state for puzzles tab
  const {
    selectedPuzzle,
    setSelectedPuzzle,
    showSolutions: puzzleShowSolutions,
    toggleSolution: puzzleToggleSolution,
    resetPuzzle,
  } = usePuzzleState();

  // Новые категории задач в правильном порядке
  const topics = [
    {
      id: "truth-tasks",
      title: "Истинностные задачи",
      icon: "CheckCircle",
      color: "green",
    },
    {
      id: "backwards-tasks",
      title: "Задачи, решаемые с конца",
      icon: "RotateCcw",
      color: "purple",
    },
    {
      id: "pouring",
      title: "Задачи на переливание",
      icon: "Droplets",
      color: "blue",
    },
    {
      id: "weighing",
      title: "Задачи на взвешивание",
      icon: "Scale",
      color: "orange",
    },
    {
      id: "who-is-who",
      title: "Задачи типа «Кто есть кто?»",
      icon: "Users",
      color: "pink",
    },
    {
      id: "sets-tasks",
      title: "Задачи на пересечение или объединение множеств",
      icon: "Venn",
      color: "cyan",
    },
    {
      id: "knights-liars",
      title: "Задачи о рыцарях и лжецах",
      icon: "Shield",
      color: "red",
    },
    {
      id: "strategy-tasks",
      title: "Задачи на выработку стратегии",
      icon: "Target",
      color: "indigo",
    },
  ];

  const getTasksByTopic = (topicId: string) => {
    // Получаем задачи из puzzleData для соответствующих категорий
    if (topicId === "pouring") {
      const pouringCategory = puzzleCategories.find(
        (cat) => cat.id === "pouring",
      );
      if (pouringCategory) {
        return {
          description:
            "Задачи на переливание жидкостей с минимальным количеством действий. Цель - отмерить нужное количество жидкости, используя сосуды разного объёма.",
          easy: pouringCategory.puzzles
            .filter((p) => p.difficulty === "Легкая")
            .map((puzzle) => ({
              text: puzzle.description,
              solution: puzzle.solution,
            })),
          medium: pouringCategory.puzzles
            .filter((p) => p.difficulty === "Средняя")
            .map((puzzle) => ({
              text: puzzle.description,
              solution: puzzle.solution,
            })),
          hard: pouringCategory.puzzles
            .filter((p) => p.difficulty === "Высокая")
            .map((puzzle) => ({
              text: puzzle.description,
              solution: puzzle.solution,
            })),
        };
      }
    }

    // Получаем логические задачи из puzzleData для остальных категорий
    const logicCategory = puzzleCategories.find((cat) => cat.id === "logic");
    if (logicCategory) {
      // Фильтруем задачи по типам из логической категории
      const getLogicTasks = (startIndex: number, count: number) => {
        return logicCategory.puzzles
          .slice(startIndex, startIndex + count)
          .map((puzzle) => ({
            text: puzzle.description,
            solution: puzzle.solution,
          }));
      };

      // Определяем задачи для каждой категории на основе данных из puzzleData
      switch (topicId) {
        case "truth-tasks":
          return {
            description:
              "Задачи на определение истинности утверждений и работу с логическими операциями.",
            easy: getLogicTasks(0, 5), // Первые 5 истинностных задач
            medium: getLogicTasks(5, 5),
            hard: getLogicTasks(10, 5),
          };
        case "backwards-tasks":
          return {
            description:
              "Задачи, которые эффективно решаются методом 'от конца к началу'.",
            easy: getLogicTasks(15, 5), // Задачи, решаемые с конца
            medium: getLogicTasks(20, 5),
            hard: getLogicTasks(25, 5),
          };
        case "weighing":
          return {
            description:
              "Задачи на поиск фальшивой монеты с помощью весов за минимальное количество взвешиваний.",
            easy: getLogicTasks(30, 5), // Задачи на взвешивание
            medium: getLogicTasks(35, 5),
            hard: getLogicTasks(40, 5),
          };
        case "who-is-who":
          return {
            description:
              "Задачи на определение соответствий между людьми и их характеристиками.",
            easy: getLogicTasks(45, 5), // Задачи типа «Кто есть кто?»
            medium: getLogicTasks(50, 5),
            hard: getLogicTasks(55, 5),
          };
        case "sets-tasks":
          return {
            description:
              "Задачи на работу с множествами, их пересечениями и объединениями.",
            easy: getLogicTasks(60, 5), // Задачи на множества
            medium: getLogicTasks(65, 5),
            hard: getLogicTasks(70, 5),
          };
        case "knights-liars":
          return {
            description:
              "Классические задачи об острове рыцарей и лжецов, где рыцари всегда говорят правду, а лжецы всегда лгут.",
            easy: [
              {
                text: "На острове живут только рыцари (всегда говорят правду) и лжецы (всегда лгут). Житель острова говорит: «Я лжец». Кто он?",
                solution:
                  "Это невозможная ситуация. Если он рыцарь, то говорит правду, но тогда он не может сказать «Я лжец». Если он лжец, то лжет, но тогда утверждение «Я лжец» было бы правдой, что противоречит его природе. Такого высказывания не может быть.",
              },
              {
                text: "Два жителя острова A и B. A говорит: «Мы оба лжецы». Кто есть кто?",
                solution:
                  "A — лжец, B — рыцарь. Если бы A был рыцарем, то его утверждение было бы правдой, значит оба лжецы, но тогда рыцарь не может быть лжецом — противоречие. Значит A — лжец, тогда его утверждение ложно, и не оба являются лжецами, следовательно B — рыцарь.",
              },
              {
                text: "Житель острова говорит: «Если я рыцарь, то завтра будет дождь». Что можно сказать о погоде?",
                solution:
                  "Завтра обязательно будет дождь. Если говорящий — рыцарь, то утверждение истинно, и завтра дождь. Если он лжец, то утверждение ложно, но импликация «если я рыцарь, то завтра дождь» при ложной предпосылке становится истинной, что противоречит природе лжеца. Значит, он может быть только рыцарем, и завтра дождь.",
              },
              {
                text: "A говорит: «B — лжец». B говорит: «Мы одного типа». Кто есть кто?",
                solution:
                  "A — рыцарь, B — лжец. Предположим A — рыцарь, тогда B действительно лжец. Если B — лжец, то его утверждение «мы одного типа» ложно, что согласуется с тем, что они разного типа. Если предположить A — лжец, то B — рыцарь, но тогда утверждение B «мы одного типа» было бы ложным, что противоречит природе рыцаря.",
              },
              {
                text: "Три жителя: A, B, C. A говорит: «Все трое — лжецы». B говорит: «Только один из нас — лжец». Что можно сказать о C?",
                solution:
                  "C — рыцарь. A не может быть рыцарем (иначе его утверждение о том, что все лжецы, включая его самого, было бы противоречивым). Значит A — лжец. Тогда не все трое лжецы. B утверждает, что только один лжец. Если B — лжец, то лжецов уже двое (A и B), и утверждение B ложно. Но тогда лжецов больше одного, что противоречит. Значит B — рыцарь, и действительно только один лжец (A). Следовательно, C — рыцарь.",
              },
            ],
            medium: [
              {
                text: "На острове есть нормальные люди (могут и лгать, и говорить правду). A говорит: «B — лжец». B говорит: «C — нормальный». C говорит: «A — лжец». Определите тип каждого.",
                solution:
                  "A — лжец, B — рыцарь, C — нормальный. Если A — рыцарь, то B — лжец, тогда утверждение B о том, что C — нормальный, ложно, значит C — не нормальный (рыцарь или лжец). Утверждение C «A — лжец» было бы ложным, значит C — лжец. Но тогда у нас A — рыцарь, B — лжец, C — лжец. Проверим: если A — лжец, то B — не лжец (рыцарь или нормальный). Если B — рыцарь, то C действительно нормальный. Тогда C может сказать «A — лжец», что соответствует действительности.",
              },
              {
                text: "Четыре жителя A, B, C, D играют в карты. A: «Среди нас ровно два лжеца». B: «A говорит правду». C: «B и D — оба лжецы». D: «C — рыцарь». Сколько лжецов?",
                solution:
                  "Три лжеца: B, C, D. Предположим A — рыцарь (говорит правду), тогда действительно два лжеца. B подтверждает, что A говорит правду, значит B — рыцарь. Тогда лжецов должно быть двое среди C и D. C говорит, что B и D — лжецы, но B — рыцарь, значит C лжет, C — лжец. D говорит, что C — рыцарь, но C — лжец, значит D тоже лжет, D — лжец. Итак, лжецы: C и D, рыцари: A и B. Но тогда утверждение A о двух лжецах верно. Однако проверим другой случай: если A — лжец, то лжецов не два. Тогда B, утверждающий, что A говорит правду, тоже лжец. C говорит, что B и D — лжецы. D говорит, что C — рыцарь. Если C — рыцарь, то B и D действительно лжецы. Тогда лжецы: A, B, D (трое), что противоречит утверждению A (которое должно быть ложным). Значит, лжецов трое: A, B, D; рыцарь: C.",
              },
              {
                text: "На развилке дорог стоят два стража. Один всегда лжет, другой всегда говорит правду, но вы не знаете, кто есть кто. Одна дорога ведет в город, другая — в пустыню. Вы можете задать только один вопрос одному из стражей. Какой вопрос гарантированно приведет вас в город?",
                solution:
                  "Спросите любого стража: 'Если я спрошу другого стража, какая дорога ведет в город, что он ответит?' Затем идите по противоположной дороге. Объяснение: если вы спрашиваете рыцаря, он честно передаст ответ лжеца (который укажет неверную дорогу). Если спрашиваете лжеца, он солжет о том, что сказал бы рыцарь (исказит правильный ответ рыцаря на неправильный). В любом случае получите указание на неверную дорогу.",
              },
              {
                text: "На острове живут рыцари, лжецы и хитрецы (отвечают правдиво на прямые вопросы, но лгут на непрямые). Житель говорит: 'Я не рыцарь и не лжец'. Кто он?",
                solution:
                  "Он хитрец. Рыцарь не может сказать 'Я не рыцарь' (это была бы ложь). Лжец не может сказать 'Я не лжец' (это была бы правда). Только хитрец может правдиво утверждать, что он не является ни рыцарем, ни лжецом.",
              },
              {
                text: "Пять жителей сидят в ряд. Каждый говорит: 'Среди моих соседей есть хотя бы один лжец'. Первый и последний имеют по одному соседу, остальные — по два. Сколько лжецов минимум?",
                solution:
                  "Минимум 2 лжеца. Пусть жители: A, B, C, D, E. A говорит про B, B говорит про A и C, C говорит про B и D, D говорит про C и E, E говорит про D. Если все утверждения истинны, то у каждого есть сосед-лжец. Но тогда у B есть сосед-лжец (A или C), у C есть сосед-лжец (B или D). Если A — лжец, то утверждение A ложно, значит B — рыцарь. Если B — рыцарь, то среди A и C есть лжец. A уже лжец, значит C может быть рыцарем. Продолжая логику: минимальное решение — A и D лжецы, B, C, E рыцари.",
              },
            ],
            hard: [
              {
                text: "На острове три типа жителей: рыцари (всегда правда), лжецы (всегда ложь) и дипломаты (могут говорить и правду, и ложь). Три жителя A, B, C. A: 'C не дипломат'. B: 'A — дипломат'. C: 'Я дипломат, если и только если B не лжец'. Определите всех.",
                solution:
                  "A — рыцарь, B — лжец, C — дипломат. Проанализируем утверждение C: 'Я дипломат ↔ B не лжец'. Если C — дипломат, то B — не лжец (рыцарь или дипломат). Если C — не дипломат, то B — лжец. Рассмотрим случаи: 1) Пусть B — лжец. Тогда по утверждению C, C — не дипломат (рыцарь или лжец). Утверждение B 'A — дипломат' ложно, значит A — не дипломат. Утверждение A 'C не дипломат' должно быть истинным (если A — рыцарь) или ложным (если A — лжец). Если A — рыцарь, то C действительно не дипломат, что согласуется. Если C — лжец, то утверждение C должно быть ложным, но 'Я дипломат ↔ B не лжец' при C не дипломат и B лжец дает 'ложь ↔ ложь', что истинно — противоречие. Значит C — рыцарь. Но тогда утверждение C истинно, и при B — лжец получаем C — не дипломат, что верно. Итак: A — рыцарь, B — лжец, C — рыцарь. Но A утверждает 'C не дипломат', что истинно. Все сходится. Проверим другие случаи аналогично — они дают противоречия.",
              },
              {
                text: "Десять жителей острова стоят в кругу. Каждый говорит: 'Из двух моих соседей ровно один — лжец'. Какие варианты распределения типов возможны?",
                solution:
                  "Возможны только конфигурации с чередованием: либо все рыцари, либо строгое чередование рыцарь-лжец. Если все рыцари, то каждый правдиво утверждает, что среди двух соседей один лжец — но соседи тоже рыцари, противоречие. Значит, не все рыцари. Пусть есть хотя бы один лжец. Рассмотрим любого рыцаря R: его утверждение истинно, значит среди его соседей ровно один лжец. Рассмотрим любого лжеца L: его утверждение ложно, значит среди его соседей НЕ ровно один лжец (либо 0, либо 2). Если у лжеца 0 лжецов-соседей, то оба соседа — рыцари, но тогда каждый из них утверждает, что среди своих соседей один лжец — получается, что у каждого рыцаря есть сосед-лжец. Единственная устойчивая конфигурация: чередование R-L-R-L-R-L-R-L-R-L.",
              },
              {
                text: "На острове суд из трех судей: рыцарей или лжецов. Они выносят решения большинством голосов. Подсудимый знает, что если спросить любого судью: 'Будет ли вердикт виновен?', то получит ответ 'Да' от рыцарей, если большинство считает виновным, и 'Нет' — если нет. От лжецов — наоборот. Подсудимый может задать один вопрос одному судье. Как гарантированно узнать вердикт?",
                solution:
                  "Спросите любого судью: 'Если я задам этот же вопрос случайно выбранному судье (включая вас), какой ответ более вероятен: Да или Нет?' Но это не работает из-за случайности. Правильный вопрос: 'Если бы я спросил у большинства судей (включая вас): «Большинство из вас считает подсудимого виновным?», то большинство ответило бы «Да»?' Анализ: если большинство считает виновным, то рыцари (которые в большинстве среди считающих виновным) ответят 'Да' на вопрос о том, считает ли большинство виновным. Лжецы ответят 'Нет'. При голосовании большинства о том, ответило ли бы большинство 'Да', получим ответ рыцарей. Аналогично для случая невиновности. Ответ 'Да' означает вердикт 'виновен', 'Нет' — 'невиновен'.",
              },
              {
                text: "Король острова хочет создать совет из 7 мудрецов. Претендентов 15: некоторые рыцари, некоторые лжецы. Король может задать каждому претенденту один вопрос вида 'Да/Нет'. Как гарантированно выбрать 7 рыцарей, если их точно не меньше 7?",
                solution:
                  "Король задает каждому: 'Среди всех остальных 14 претендентов рыцарей больше, чем лжецов?' Пусть среди 15 претендентов R рыцарей и L лжецов, R ≥ 7, R + L = 15. Каждый рыцарь видит среди остальных 14: (R-1) рыцарей и L лжецов. Каждый лжец видит среди остальных 14: R рыцарей и (L-1) лжецов. Рыцарь ответит 'Да', если R-1 > L, то есть R > L+1, то есть R ≥ L+1. Поскольку R + L = 15 и R ≥ 7, то L ≤ 8, и R ≥ 7. Если R = 7, то L = 8, тогда R-1 = 6 < 8 = L, рыцари ответят 'Нет'. Если R ≥ 8, то L ≤ 7, тогда R-1 ≥ 7 > L, рыцари ответят 'Да'. Лжецы дают противоположные ответы. Если R = 7: рыцари говорят 'Нет', лжецы говорят 'Да'. Выбираем 7 ответивших 'Нет'. Если R ≥ 8: рыцари говорят 'Да', лжецы говорят 'Нет'. Выбираем 7 из ответивших 'Да'.",
              },
              {
                text: "Архипелаг из 100 островов. На каждом острове либо только рыцари, либо только лжецы. Путешественник посещает острова и на каждом спрашивает одного жителя: 'На большинстве островов архипелага живут рыцари?' Получив все ответы, как определить истинное соотношение?",
                solution:
                  "Пусть R островов с рыцарями, L островов с лжецами, R + L = 100. Житель острова рыцарей ответит 'Да', если R > 50, и 'Нет', если R ≤ 50. Житель острова лжецов ответит наоборот. Пусть путешественник получил Y ответов 'Да' и N ответов 'Нет', Y + N = 100. Случай 1: R > 50. Тогда рыцари говорят 'Да', лжецы говорят 'Нет'. Значит Y = R, N = L. Случай 2: R < 50. Тогда рыцари говорят 'Нет', лжецы говорят 'Да'. Значит Y = L, N = R. Случай 3: R = 50. Тогда рыцари говорят 'Нет', лжецы говорят 'Да'. Значит Y = L = 50, N = R = 50. Алгоритм: Если Y = N = 50, то R = L = 50. Если Y > N, то либо R = Y > 50 (случай 1), либо L = Y и R = N < 50 (случай 2, но тогда L > 50, что означает R < 50). Нужна дополнительная информация или другая стратегия опроса.",
              },
            ],
          };
        case "strategy-tasks":
          return {
            description:
              "Задачи на разработку оптимальных стратегий в играх и жизненных ситуациях.",
            easy: [
              {
                text: "Игра 'Камни': На столе лежат 15 камней. Два игрока по очереди берут 1, 2 или 3 камня. Кто берет последний камень — проигрывает. Как гарантированно выиграть, если вы ходите первым?",
                solution:
                  "Выигрышная стратегия: всегда оставляйте противнику количество камней, кратное 4. Первым ходом берите 3 камня (остается 12). Затем какой бы ход ни сделал противник (1, 2 или 3), вы берете камней столько, чтобы вместе с его ходом получилось 4. Так вы всегда будете оставлять ему 8, затем 4 камня, и в конце он будет вынужден взять последний.",
              },
              {
                text: "Игра 'Спички': 21 спичка разложена в ряд. Игроки по очереди берут 1, 2 или 3 спички подряд. Кто берет последнюю — выигрывает. Какая стратегия гарантирует победу?",
                solution:
                  "Выигрышная стратегия для первого игрока: всегда оставляйте противнику количество спичек вида 4k+1. Первым ходом берите 1 спичку (остается 20 = 4×5). Затем, сколько бы ни взял противник (1, 2 или 3), вы берете столько, чтобы вместе получилось 4. Так вы приведете игру к позиции, где у противника 1 спичка, и он будет вынужден взять ее — вы выиграете.",
              },
              {
                text: "У вас есть 8 монет, одна из которых фальшивая (легче настоящих). Есть чашечные весы. За какое минимальное количество взвешиваний можно найти фальшивую монету?",
                solution:
                  "За 2 взвешивания. Стратегия: 1) Разделите монеты на 3 группы: 3, 3, 2. Взвесьте две группы по 3 монеты. Если весы в равновесии — фальшивая в группе из 2 монет. Если одна группа легче — фальшивая в ней. 2) Если фальшивая в группе из 2 монет — взвесьте любую из них с настоящей. Если фальшивая в группе из 3 монет — взвесьте любые 2 из них: если равны — фальшивая третья, если нет — фальшивая та, что легче.",
              },
              {
                text: "Шоколадка 4×4 клетки. Двое игроков по очереди отламывают прямоугольные куски (по линиям между клетками). Кто получит клетку в левом верхнем углу — выигрывает. Кто выиграет при оптимальной игре?",
                solution:
                  "Выиграет второй игрок. Стратегия: используйте симметрию относительно левой верхней клетки. Если первый игрок делает ход, который отрывает кусок, не содержащий целевую клетку, второй игрок делает симметричный ход относительно этой клетки. Если первый игрок пытается взять кусок с целевой клеткой, это означает, что вся шоколадка кроме этого куска уже отломана, но тогда это должен быть ход второго игрока (поскольку количество клеток 16 — четное). Второй игрок может поддерживать симметрию до конца.",
              },
              {
                text: "В мешке 100 шариков: 50 красных и 50 синих. Двое игроков по очереди вытаскивают по одному шарику. Выигрывает тот, кто вытащит больше красных шариков. Какая стратегия оптимальна?",
                solution:
                  "При случайном вытаскивании у каждого игрока равные шансы — 25 красных шариков в среднем. Оптимальная стратегия: играть честно, так как никто не может влиять на цвет вытаскиваемого шарика. Результат зависит только от удачи. Если игра продолжается до конца, то у кого-то будет больше красных шариков, но предсказать это заранее невозможно. Математическое ожидание выигрыша — 0 для каждого игрока.",
              },
            ],
            medium: [
              {
                text: "Игра 'Башни Ханоя' для двух игроков: 7 дисков на первом стержне, 3 стержня всего. Игроки по очереди делают корректные ходы. Кто переместит последний диск на третий стержень — выигрывает. Кто выиграет?",
                solution:
                  "Выиграет первый игрок. Оптимальное решение классической задачи о Башнях Ханоя требует 2^7 - 1 = 127 ходов. Поскольку 127 — нечетное число, последний (127-й) ход сделает первый игрок. Стратегия для первого игрока: всегда делайте ходы, которые приближают к оптимальному решению. Ключевой принцип: всегда перемещайте самый маленький диск в одном направлении (например, по часовой стрелке между стержнями), а остальные ходы делайте единственным возможным способом.",
              },
              {
                text: "На шахматной доске 8×8 расставлены 32 домино (каждое покрывает 2 клетки). Двое игроков по очереди убирают одно домино. Кто не может сделать ход — проигрывает. Какая стратегия гарантирует победу?",
                solution:
                  "Выиграет второй игрок, используя стратегию симметрии. Мысленно разделите доску на две равные части (например, левую и правую половины по 4 столбца). Установите соответствие между позициями домино в левой и правой половинах. Когда первый игрок убирает домино, второй игрок убирает симметрично расположенное домино в другой половине. Если симметричного домино нет, значит, первый игрок нарушил симметрию ранее, и можно восстановить ее. Таким образом, у первого игрока всегда будет ход, пока у второго есть ход.",
              },
              {
                text: "Игра 'Сим': На плоскости отмечено 6 точек, все соединены отрезками (полный граф). Двое игроков по очереди красят отрезки в свой цвет. Кто создаст одноцветный треугольник — проигрывает. Кто выиграет?",
                solution:
                  "Эта игра всегда заканчивается поражением одного из игроков — ничьих не бывает. Согласно теореме Рамсея R(3,3) = 6, в полном графе на 6 вершинах при раскраске ребер двумя цветами всегда найдется одноцветный треугольник. Стратегия: старайтесь играть симметрично и заставлять противника первым создавать опасные конфигурации. Конкретная выигрышная стратегия сложна, но известно, что при идеальной игре второй игрок может добиться ничьей... но поскольку ничьих не бывает, игра теоретически решена в пользу одного из игроков (доказательство очень сложное).",
              },
              {
                text: "Аукцион: Продается предмет стоимостью 100 рублей. Каждый из двух участников одновременно называет свою ставку. Кто назвал больше — получает предмет и платит свою ставку. При равенстве ставок предмет достается случайно. Какая оптимальная стратегия?",
                solution:
                  "Это игра с смешанными стратегиями. Чистой выигрышной стратегии нет. Оптимальная стратегия: случайно выбирать ставку из интервала [0, 100] согласно равномерному распределению. Интуитивно: если противник всегда ставит x, вы можете поставить x + ε и выиграть. Но если он знает вашу стратегию, он может поставить больше. В равновесии Нэша оба игрока используют равномерное распределение на [0, 100], и математическое ожидание выигрыша каждого равно 0.",
              },
              {
                text: "Игра 'Морской бой' 1×n: Корабли длиной 1 клетка расставлены на доске 1×10. Игрок знает, что кораблей ровно 3, но не знает где. За каждый выстрел платит 1 рубль, за каждый потопленный корабль получает 5 рублей. Какая стратегия максимизирует ожидаемую прибыль?",
                solution:
                  "Оптимальная стратегия: стрелять через одну клетку до первого попадания, затем искать остальные корабли систематически. Если стрелять в клетки 1, 3, 5, 7, 9, то гарантированно найдете все корабли максимум за 8 выстрелов (5 + 3 дополнительных). Ожидаемое количество выстрелов ≈ 6.7, ожидаемая прибыль = 3×5 - 6.7×1 = 8.3 рубля. Альтернатива: случайная стрельба дает ожидаемую прибыль около 5.5 рублей. Систематический подход лучше.",
              },
            ],
            hard: [
              {
                text: "Игра 'Чёрный ящик': В ящике лежат 2 шара — каждый либо красный, либо синий. Вы не знаете их цвета. За 1 рубль можете вытащить шар, посмотреть цвет и положить обратно. Затем делаете ставку на цвет второго шара (красный или синий). Если угадали — получаете 3 рубля. Какая оптимальная стратегия?",
                solution:
                  "Оптимальная стратегия зависит от предполагаемого распределения цветов шаров. Если все комбинации равновероятны (КК, КС, СК, СС с вероятностями 1/4 каждая), то: 1) Если не покупать информацию: ожидаемый выигрыш = 0.5×3 - 0 = 1.5 рубля. 2) Если купить информацию: увидев красный шар, вероятность что второй красный = 1/3 (из комбинаций КК, КС, СК остаются КК и КС, где второй красный только в КК). Ожидаемый выигрыш = 0.5×3 - 1 = 0.5 рубля. Не покупать информацию выгоднее! Парадокс объясняется тем, что информация о первом шаре мало говорит о втором в данной модели.",
              },
              {
                text: "Игра 'Дилемма заключенного' с повторениями: Два игрока играют 1000 раундов. В каждом раунде выбирают 'Сотрудничать' или 'Предать'. Платежи за раунд: (С,С)→(3,3), (С,П)→(0,5), (П,С)→(5,0), (П,П)→(1,1). Какая стратегия оптимальна против разумного противника?",
                solution:
                  "Оптимальная стратегия: 'Око за око с прощением' (Tit-for-Tat with Forgiveness). Алгоритм: 1) В первом раунде сотрудничайте. 2) В каждом следующем раунде повторяйте действие противника из предыдущего раунда. 3) С вероятностью 5-10% прощайте предательство и сотрудничайте. Эта стратегия: а) Поощряет взаимное сотрудничество (3+3=6 очков за раунд против 1+1=2 при взаимном предательстве). б) Наказывает предательство. в) Позволяет восстановить сотрудничество после случайных конфликтов. г) Не дает себя эксплуатировать. Против такой стратегии лучший ответ противника — тоже сотрудничать.",
              },
              {
                text: "Торги 'Война на истощение': Два игрока борются за приз стоимостью 100 рублей. Каждый раунд они одновременно решают: продолжать (платить 1 рубль) или сдаться. Если один сдается — другой получает приз. Если оба сдаются — приз пропадает. Какая оптимальная стратегия?",
                solution:
                  "Это классическая модель 'войны на истощение'. Оптимальная стратегия смешанная: в каждом раунде продолжать с вероятностью p, где p убывает со временем. Конкретно: если прошло t раундов, продолжать с вероятностью p(t) = max(0, (100-t)/100). Интуиция: чем дольше длится борьба, тем меньше остается от приза после вычета затрат, поэтому нужно чаще сдаваться. В равновесии Нэша ожидаемый выигрыш каждого игрока стремится к нулю — весь приз 'съедается' затратами на борьбу. Практический вывод: избегайте войн на истощение, ищите компромиссы.",
              },
              {
                text: "Сетевая игра: 6 игроков расположены в вершинах шестиугольника. Каждый игрок выбирает одну из двух стратегий: A или B. Выигрыш игрока зависит от его стратегии и стратегий соседей. Если игрок выбрал A, он получает 2 очка за каждого соседа с A и 0 за каждого с B. Если выбрал B — получает 1 очко за каждого соседа независимо от их стратегии. Найдите все равновесия Нэша.",
                solution:
                  "Найдем равновесия Нэша, анализируя лучшие ответы. Для игрока с k соседями, выбравшими A: выигрыш от A = 2k, выигрыш от B = k+(2-k) = 2. Стратегия A лучше, если 2k > 2, то есть k > 1. У каждого игрока 2 соседа. Равновесия: 1) Все выбирают A: каждый получает 2×2=4 очка. Если кто-то перейдет на B, получит 2 очка — хуже. 2) Все выбирают B: каждый получает 2 очка. Если кто-то перейдет на A, получит 2×0=0 очков — хуже. 3) Чередование A-B-A-B-A-B: игроки с A получают 2×0=0, с B получают 2. Если A перейдет на B, получит 2 (не хуже). Если B перейдет на A, получит 2×0=0 (хуже). Это тоже равновесие. Итого: 3 равновесия.",
              },
              {
                text: "Аукцион 'Доллар за доллар': Продается купюра в 1 доллар. Участники делают ставки. Победитель получает доллар, но и победитель, и проигравший платят свои ставки. Если я участвую и текущая максимальная ставка 60 центов, какая оптимальная стратегия?",
                solution:
                  "Это классическая 'ловушка эскалации'. Оптимальная стратегия: НЕ УЧАСТВОВАТЬ вообще или выйти немедленно. Анализ: если максимальная ставка 60¢, то для выигрыша нужно поставить минимум 61¢. Но тогда противник может поставить 62¢, и так далее. Когда ставки превысят $1, оба игрока будут в убытке, но каждому выгоднее повышать ставку (чтобы хотя бы получить доллар) чем сдаться (и потерять всю ставку). Это приводит к бесконечной эскалации. Единственный способ выиграть — не играть. Если уже участвуете при ставке 60¢, наименьший ущерб — сдаться сейчас и потерять только текущую ставку.",
              },
            ],
          };
        default:
          return {
            description:
              "Описание данного типа задач будет добавлено в следующих обновлениях.",
            easy: [
              {
                text: "Задача 1 (легкий уровень)",
                solution: "Решение задачи 1",
              },
              {
                text: "Задача 2 (легкий уровень)",
                solution: "Решение задачи 2",
              },
              {
                text: "Задача 3 (легкий уровень)",
                solution: "Решение задачи 3",
              },
              {
                text: "Задача 4 (легкий уровень)",
                solution: "Решение задачи 4",
              },
              {
                text: "Задача 5 (легкий уровень)",
                solution: "Решение задачи 5",
              },
            ],
            medium: [
              {
                text: "Задача 1 (средний уровень)",
                solution: "Решение задачи 1",
              },
              {
                text: "Задача 2 (средний уровень)",
                solution: "Решение задачи 2",
              },
              {
                text: "Задача 3 (средний уровень)",
                solution: "Решение задачи 3",
              },
              {
                text: "Задача 4 (средний уровень)",
                solution: "Решение задачи 4",
              },
              {
                text: "Задача 5 (средний уровень)",
                solution: "Решение задачи 5",
              },
            ],
            hard: [
              {
                text: "Задача 1 (сложный уровень)",
                solution: "Решение задачи 1",
              },
              {
                text: "Задача 2 (сложный уровень)",
                solution: "Решение задачи 2",
              },
              {
                text: "Задача 3 (сложный уровень)",
                solution: "Решение задачи 3",
              },
              {
                text: "Задача 4 (сложный уровень)",
                solution: "Решение задачи 4",
              },
              {
                text: "Задача 5 (сложный уровень)",
                solution: "Решение задачи 5",
              },
            ],
          };
      }
    }

    // Fallback для случаев, когда данные не найдены
    return {
      description:
        "Описание данного типа задач будет добавлено в следующих обновлениях.",
      easy: Array(5)
        .fill(null)
        .map((_, i) => ({
          text: `Задача ${i + 1} (легкий уровень)`,
          solution: `Решение задачи ${i + 1}`,
        })),
      medium: Array(5)
        .fill(null)
        .map((_, i) => ({
          text: `Задача ${i + 1} (средний уровень)`,
          solution: `Решение задачи ${i + 1}`,
        })),
      hard: Array(5)
        .fill(null)
        .map((_, i) => ({
          text: `Задача ${i + 1} (сложный уровень)`,
          solution: `Решение задачи ${i + 1}`,
        })),
    };
  };

  const toggleSolution = (taskId: string) => {
    setShowSolutions((prev) => ({
      ...prev,
      [taskId]: !prev[taskId],
    }));
  };

  const renderTaskLevel = (
    tasks: any[],
    level: string,
    levelTitle: string,
    description: string,
  ) => (
    <Card className="mb-6">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <span
            className={`px-3 py-1 rounded-full text-sm font-medium ${
              level === "easy"
                ? "bg-green-100 text-green-800"
                : level === "medium"
                  ? "bg-yellow-100 text-yellow-800"
                  : "bg-red-100 text-red-800"
            }`}
          >
            {levelTitle}
          </span>
        </CardTitle>
        <CardDescription>{description}</CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {tasks.map((task, index) => {
          const taskId = `${level}-${index}`;
          return (
            <div key={index} className="border rounded-lg p-4 space-y-3">
              <p className="text-gray-700 leading-relaxed">{task.text}</p>
              <Button
                variant="outline"
                size="sm"
                onClick={() => toggleSolution(taskId)}
                className="text-blue-600 hover:text-blue-700"
              >
                {showSolutions[taskId] ? "Скрыть решение" : "Решение"}
              </Button>
              {showSolutions[taskId] && (
                <div className="bg-blue-50 border-l-4 border-blue-400 p-4 rounded">
                  <p className="text-blue-800 text-sm font-medium mb-2">
                    Решение:
                  </p>
                  <p className="text-blue-700">{task.solution}</p>
                </div>
              )}
            </div>
          );
        })}
      </CardContent>
    </Card>
  );

  // Если выбрана подтема
  if (selectedTopic && selectedSubtopic) {
    const topic = topics.find((t) => t.id === selectedTopic)!;
    const subtopic = topic.subtopics.find((s) => s.id === selectedSubtopic)!;
    const tasks = getTasksBySubtopic(selectedTopic, selectedSubtopic);

    return (
      <div className="max-w-4xl mx-auto space-y-6">
        <div className="flex items-center justify-between">
          <h1 className="text-3xl font-bold text-gray-800">
            {topic.title}: {subtopic.title}
          </h1>
          <Button variant="outline" onClick={() => setSelectedSubtopic(null)}>
            <Icon name="ArrowLeft" size={16} className="mr-2" />К видам задач
          </Button>
        </div>

        <Card className="bg-blue-50 border-blue-200">
          <CardContent className="pt-6">
            <p className="text-blue-800">{tasks.description}</p>
          </CardContent>
        </Card>

        {renderTaskLevel(
          tasks.easy,
          "easy",
          "Легкий",
          "Задачи, решаемые в 1-2 шага",
        )}
        {renderTaskLevel(
          tasks.medium,
          "medium",
          "Средний",
          "Задачи, требующие логической последовательности в рассуждениях",
        )}
        {renderTaskLevel(
          tasks.hard,
          "hard",
          "Сложный",
          "Задачи, требующие нестандартного решения и применения логики",
        )}
      </div>
    );
  }

  // Если выбрана тема
  if (selectedTopic) {
    const topic = topics.find((t) => t.id === selectedTopic)!;
    const tasks = getTasksByTopic(selectedTopic);

    return (
      <div className="max-w-4xl mx-auto space-y-6">
        <div className="flex items-center justify-between">
          <h1 className="text-3xl font-bold text-gray-800">{topic.title}</h1>
          <Button variant="outline" onClick={() => setSelectedTopic(null)}>
            <Icon name="ArrowLeft" size={16} className="mr-2" />К темам
          </Button>
        </div>

        <Card className="bg-blue-50 border-blue-200">
          <CardContent className="pt-6">
            <p className="text-blue-800">{tasks.description}</p>
          </CardContent>
        </Card>

        {renderTaskLevel(
          tasks.easy,
          "easy",
          "Легкий",
          "Задачи, решаемые в 1-2 шага",
        )}
        {renderTaskLevel(
          tasks.medium,
          "medium",
          "Средний",
          "Задачи, требующие логической последовательности в рассуждениях",
        )}
        {renderTaskLevel(
          tasks.hard,
          "hard",
          "Сложный",
          "Задачи, требующие нестандартного решения и применения логики",
        )}
      </div>
    );
  }

  // Главная страница с темами
  return (
    <div className="space-y-8">
      <div className="text-center space-y-4">
        <h1 className="text-4xl font-bold text-gray-800">
          Занимательные задачи
        </h1>
        <p className="text-lg text-gray-600 max-w-3xl mx-auto">
          Выберите раздел для изучения увлекательных логических задач и
          головоломок
        </p>
      </div>

      <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
        <TabsList className="grid w-full grid-cols-3 max-w-2xl mx-auto">
          <TabsTrigger value="logic" className="flex items-center gap-2">
            <Icon name="Brain" size={16} />
            Логические задачи
          </TabsTrigger>
          <TabsTrigger value="puzzles" className="flex items-center gap-2">
            <Icon name="Puzzle" size={16} />
            Головоломки
          </TabsTrigger>
          <TabsTrigger value="grade-six" className="flex items-center gap-2">
            <Icon name="BookOpen" size={16} />
            Задачи для 6-го класса
          </TabsTrigger>
        </TabsList>

        <TabsContent value="logic" className="mt-8">
          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6 max-w-6xl mx-auto">
            {topics.map((topic) => (
              <Card
                key={topic.id}
                className="hover:shadow-xl transition-all duration-300 cursor-pointer group"
                onClick={() => setSelectedTopic(topic.id)}
              >
                <CardHeader className="text-center">
                  <div
                    className={`w-16 h-16 bg-${topic.color}-100 text-${topic.color}-600 rounded-full flex items-center justify-center mx-auto mb-4 group-hover:scale-110 transition-transform`}
                  >
                    <Icon name={topic.icon as any} size={32} />
                  </div>
                  <CardTitle className="text-xl">{topic.title}</CardTitle>
                </CardHeader>
              </Card>
            ))}
          </div>
        </TabsContent>

        <TabsContent value="puzzles" className="mt-8">
          {selectedPuzzle ? (
            (() => {
              const puzzle = puzzleCategories
                .flatMap((cat) => cat.puzzles)
                .find((p) => p.id === selectedPuzzle);

              if (!puzzle) return null;

              return (
                <PuzzleDetail
                  puzzle={puzzle}
                  showSolution={puzzleShowSolutions[puzzle.id]}
                  onToggleSolution={puzzleToggleSolution}
                  onBack={resetPuzzle}
                />
              );
            })()
          ) : (
            <div className="space-y-6">
              <div className="text-center space-y-2">
                <h2 className="text-2xl font-bold text-gray-800">
                  Головоломки и задачи
                </h2>
                <p className="text-gray-600">
                  Развивайте логическое мышление через интересные головоломки
                </p>
              </div>

              <Tabs defaultValue={puzzleCategories[0].id} className="w-full">
                <TabsList className="grid w-full grid-cols-3">
                  {puzzleCategories.map((category) => (
                    <TabsTrigger
                      key={category.id}
                      value={category.id}
                      className="flex items-center gap-2"
                    >
                      <Icon name={category.icon} size={16} />
                      {category.title}
                    </TabsTrigger>
                  ))}
                </TabsList>

                {puzzleCategories.map((category) => (
                  <TabsContent
                    key={category.id}
                    value={category.id}
                    className="mt-6"
                  >
                    <PuzzleGrid
                      puzzles={category.puzzles}
                      onSelectPuzzle={setSelectedPuzzle}
                    />
                  </TabsContent>
                ))}
              </Tabs>
            </div>
          )}
        </TabsContent>

        <TabsContent value="grade-six" className="mt-8">
          <GradeSixTasks />
        </TabsContent>
      </Tabs>

      <Card className="bg-gradient-to-r from-purple-50 to-blue-50 border-purple-200 max-w-4xl mx-auto">
        <CardHeader>
          <CardTitle className="flex items-center gap-2 text-center">
            <Icon name="Star" className="text-yellow-500" size={24} />
            Особенности занимательных задач
          </CardTitle>
        </CardHeader>
        <CardContent className="grid md:grid-cols-2 gap-4 text-sm">
          <div className="space-y-2">
            <p>• Развитие аналитического мышления</p>
            <p>• Тренировка логических рассуждений</p>
            <p>• Пошаговые решения для понимания</p>
          </div>
          <div className="space-y-2">
            <p>• Задачи разного уровня сложности</p>
            <p>• Классические головоломки и задачи</p>
            <p>• Подготовка к олимпиадам</p>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default EntertainingProblemsSection;
